// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SortFragments

// Linked list structure
struct PPLL_STRUCT
{
    uint	TangentAndCoverage;	
    uint	depth;
    uint    uNext;
    uint    ammountLight;
};

struct KBUFFER_STRUCT
{
	float depth;
	float3 tangent;
	float coverage;
	float ammountLight;
};

// Linked List resources
RWTexture2D<uint> LinkedListHead;
RWStructuredBuffer<struct PPLL_STRUCT> LinkedList;

// Screen information
float4 screenSize;

// Final result
RWTexture2D<float4> Result;

#define THREAD_GROUP_SIZE 8
#define NULLPOINTER 0xffffffff
#define MAX_FRAGMENTS 256
#define KBUFFER_SIZE 8
#define COLORDEBUG

// HELPER FUNCTIONS
uint PackFloat4IntoUint(float4 vValue)
{
    return ( (uint(vValue.x*255)& 0xFFUL) << 24 ) | ( (uint(vValue.y*255)& 0xFFUL) << 16 ) | ( (uint(vValue.z*255)& 0xFFUL) << 8) | (uint(vValue.w * 255)& 0xFFUL);
}

float4 UnpackUintIntoFloat4(uint uValue)
{
    return float4( ( (uValue & 0xFF000000)>>24 ) / 255.0, ( (uValue & 0x00FF0000)>>16 ) / 255.0, ( (uValue & 0x0000FF00)>>8 ) / 255.0, ( (uValue & 0x000000FF) ) / 255.0);
}

uint PackTangentAndCoverage(float3 tangent, float coverage)
{
    return PackFloat4IntoUint( float4(tangent.xyz*0.5 + 0.5, coverage) );
}

float3 GetTangent(uint packedTangent)
{
    return 2.0 * UnpackUintIntoFloat4(packedTangent).xyz - 1.0;
}

float GetCoverage(uint packedCoverage)
{
    return UnpackUintIntoFloat4(packedCoverage).w;
}

[numthreads(THREAD_GROUP_SIZE,THREAD_GROUP_SIZE,1)]
void SortFragments (uint3 id : SV_DispatchThreadID)
{
	// Bounds check
	if (id.x > (uint)screenSize.x || id.y > (uint)screenSize.y)
		return;
	
	// Get first index
	uint pointer = LinkedListHead[id.xy];
		
	// NULLPOINTER check
	if (pointer == NULLPOINTER)
	{
		return;
	}
	
	int nNumFragments = 0;
	KBUFFER_STRUCT kBuffer[KBUFFER_SIZE];
	
	uint i = 0;
	
	// Initialize kbuffer
	for (i = 0; i < KBUFFER_SIZE; i++)
	{
		kBuffer[i].depth = 1000000.0f;
	}
	
	// Get all fragments
	for (i = 0; i < MAX_FRAGMENTS; i++)
	{
		if (pointer != NULLPOINTER)
		{
			pointer = LinkedList[pointer].uNext;
			
			// K-Buffer
			for (int j = 0; j < KBUFFER_SIZE; j++)
			{
				// Check if this fragment should be in the kbuffer
				if (kBuffer[j].depth > asfloat(LinkedList[pointer].depth))
				{
					// Should be in the kbuffer!
					kBuffer[j].depth = LinkedList[pointer].depth;
					kBuffer[j].tangent = GetTangent(LinkedList[pointer].TangentAndCoverage);
					kBuffer[j].coverage = GetCoverage(LinkedList[pointer].TangentAndCoverage);
					kBuffer[j].ammountLight = LinkedList[pointer].ammountLight;
					
					break;
				}
			}
			
			nNumFragments++;
		}
	}
	
	#ifdef COLORDEBUG
    float3 fcolor = float3(0,1,0);
    if (nNumFragments>32) fcolor.xyz = float3(1,1,0);
    if (nNumFragments>64) fcolor.xyz = float3(1,0.5,0);
    if (nNumFragments>128) fcolor.xyz = float3(1,0,0);
    
	Result[id.xy] = float4(fcolor, 1);
	#else
	
	
	
	#endif
}
