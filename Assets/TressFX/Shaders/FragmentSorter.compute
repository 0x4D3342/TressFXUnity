// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SortFragments

// Linked list structure
struct PPLL_STRUCT
{
    uint	TangentAndCoverage;	
    float	depth;
    uint    uNext;
    half   shadowAmmount;
    float2	worldPos;
};

struct KBUFFER_STRUCT
{
	float depth;
	float3 tangent;
	float coverage;
	float shadowAmmount;
    float2	worldPos;
};

// Linked List resources
RWTexture2D<uint> LinkedListHead;
RWStructuredBuffer<struct PPLL_STRUCT> LinkedList;

// Screen information
float4 screenSize;
float4x4 InvVPMatrix;
float4 g_vEye;

// Material information
float4 g_MatBaseColor;
float g_MatKd;
float g_MatKa;
float g_MatKs1;
float g_MatEx1;
float g_MatKs2;
float g_MatEx2;

// Light info
float3 g_DirectionalLightDir;
float4 g_AmbientLightColor;
float4 g_DirectionalLightColor;
float g_DirectionalLightIntensity;

// Final result
RWTexture2D<float4> Result;

#define THREAD_GROUP_SIZE 8
#define NULLPOINTER 0xffffffff
#define MAX_FRAGMENTS 756
#define KBUFFER_SIZE 8
#define PI 3.1415926
#define SUPERSIMPLESHADING
// #define COLORDEBUG


//--------------------------------------------------------------------------------------
// ComputeHairShading
//
// Hair shading using dual highlight approach and Kajiya lighting model
// dual highlight: marschner 03 
// kajiya model: kajiya 84
//--------------------------------------------------------------------------------------
float3 ComputeHairShading(float3 iPos, float3 iTangent, float shadowAmmount)
{
    float3 baseColor = g_MatBaseColor.xyz;
    float rand_value = 1;
    
    /*if(abs(iTex.x) + abs(iTex.y) >1e-5) // if texcoord is available, use texture map
        rand_value = g_txNoise.SampleLevel(g_samLinearWrap, iTex.xy, 0).x;*/
    
    // define baseColor and Ka Kd Ks coefficient for hair
 	float Kd = g_MatKd;
    float Ka = g_MatKa;
	float Ks1 = g_MatKs1;
	float Ex1 = g_MatEx1;
	float Ks2 = g_MatKs2;
	float Ex2 = g_MatEx2;

    float3 vLightDir = g_DirectionalLightDir; // normalize(lightPos - iPos.xyz);
	// shadowAmmount *= (g_DirectionalLightIntensity * dot(cross(iTangent, float3(-1,0,0)), vLightDir));
    float3 vEyeDir = normalize(g_vEye.xyz - iPos.xyz);
    float3 tangent = normalize(iTangent);

    // in Kajiya's model: diffuse component: sin(t, l)
    float cosTL = (dot(tangent, vLightDir));
    float sinTL = sqrt(1 - cosTL*cosTL);
    float diffuse = sinTL; // here sinTL is apparently larger than 0

    float alpha = (rand_value * 10) * PI/180; // tiled angle (5-10 dgree)

    // in Kajiya's model: specular component: cos(t, rl) * cos(t, e) + sin(t, rl)sin(t, e)
    float cosTRL = -cosTL;
    float sinTRL = sinTL;
    float cosTE = (dot(tangent, vEyeDir));
    float sinTE = sqrt(1- cosTE*cosTE);

    // primary highlight: reflected direction shift towards root (2 * Alpha)
    float cosTRL_root = cosTRL * cos(2 * alpha) - sinTRL * sin(2 * alpha);
    float sinTRL_root = sqrt(1 - cosTRL_root * cosTRL_root);
    float specular_root = max(0, cosTRL_root * cosTE + sinTRL_root * sinTE);

    // secondary highlight: reflected direction shifted toward tip (3*Alpha)
    float cosTRL_tip = cosTRL*cos(-3*alpha) - sinTRL*sin(-3*alpha);
    float sinTRL_tip = sqrt(1 - cosTRL_tip * cosTRL_tip);
    float specular_tip = max(0, cosTRL_tip * cosTE + sinTRL_tip * sinTE);

    float3 vColor = Ka * g_AmbientLightColor.xyz * baseColor + // ambient
                    shadowAmmount * g_DirectionalLightColor.xyz * (
                    Kd * diffuse * baseColor + // diffuse
                    Ks1 * pow(specular_root, Ex1)  + // primary hightlight r
                    Ks2 * pow(specular_tip, Ex2) * baseColor); // secondary highlight rtr 

   return vColor;
}

//--------------------------------------------------------------------------------------
// SimpleHairShading
//
// Low quality, but faster hair shading
//--------------------------------------------------------------------------------------
float3 SimpleHairShading(float3 iPos, float3 iTangent, float shadowAmmount)
{
    
    float3 baseColor = g_MatBaseColor.xyz;
 	float Kd = g_MatKd;
   
#ifdef SUPERSIMPLESHADING
	float3 vColor = shadowAmmount * Kd * baseColor;
#else
    float Ka = g_MatKa;
	float Ks1 = g_MatKs1;
	float Ex1 = g_MatEx1;
	float Ks2 = g_MatKs2;
	float Ex2 = g_MatEx2;
	
    float3 lightPos = float3(50, 150, 0); // g_PointLightPos.xyz;
    float3 vLightDir = g_DirectionalLightDir; // normalize(lightPos - iPos.xyz);
    float3 tangent = normalize(iTangent);

    // in Kajiya's model: diffuse component: sin(t, l)
    float cosTL = (dot(tangent, vLightDir));
    float sinTL = sqrt(1 - cosTL*cosTL);
    float diffuse = sinTL; // here sinTL is apparently larger than 0

    float3 vColor = Ka * g_AmbientLightColor.xyz * baseColor +							// ambient
                     * g_DirectionalLightColor.xyz * (Kd * diffuse * baseColor);	// diffuse
#endif

    return vColor;
}

// HELPER FUNCTIONS
uint PackFloat4IntoUint(float4 vValue)
{
    return ( (uint(vValue.x*255)& 0xFFUL) << 24 ) | ( (uint(vValue.y*255)& 0xFFUL) << 16 ) | ( (uint(vValue.z*255)& 0xFFUL) << 8) | (uint(vValue.w * 255)& 0xFFUL);
}

float4 UnpackUintIntoFloat4(uint uValue)
{
    return float4( ( (uValue & 0xFF000000)>>24 ) / 255.0, ( (uValue & 0x00FF0000)>>16 ) / 255.0, ( (uValue & 0x0000FF00)>>8 ) / 255.0, ( (uValue & 0x000000FF) ) / 255.0);
}

uint PackTangentAndCoverage(float3 tangent, float coverage)
{
    return PackFloat4IntoUint( float4(tangent.xyz*0.5 + 0.5, coverage) );
}

float3 GetTangent(uint packedTangent)
{
    return 2.0 * UnpackUintIntoFloat4(packedTangent).xyz - 1.0;
}

float GetCoverage(uint packedCoverage)
{
    return UnpackUintIntoFloat4(packedCoverage).w;
}

[numthreads(THREAD_GROUP_SIZE,THREAD_GROUP_SIZE,1)]
void SortFragments (uint3 id : SV_DispatchThreadID)
{
	// Bounds check
	if (id.x > (uint)screenSize.x || id.y > (uint)screenSize.y)
		return;
	
	// Get first index
	uint pointer = LinkedListHead[id.xy];
	
	// NULLPOINTER check
	if (pointer == NULLPOINTER)
	{
		Result[id.xy] = float4(0,0,0,1);
		return;
	}
	
	// Needed variables
	#ifdef COLORDEBUG
		uint nNumFragments = 0;
	#endif
	
	KBUFFER_STRUCT kBuffer[KBUFFER_SIZE];
	float4 fcolor = float4(0,0,0,1);
	float depth;
	float3 tangent;
	float coverage;
	float shadowAmmount;
	float2 worldPos;
	float maxDepth = 0;
	uint maxDepthIndex = 0;
	
	// Counters
	uint i = 0;
	uint j = 0;
	
	// Will hold the actual count of elements in the kbuffer
	uint kBufferFragments = 0;
	
	// Get the first k fragments
	for (i = 0; i < KBUFFER_SIZE; i++)
	{
		if (pointer != NULLPOINTER)
		{
			kBuffer[i].depth = LinkedList[pointer].depth;
			kBuffer[i].tangent = GetTangent(LinkedList[pointer].TangentAndCoverage);
			kBuffer[i].coverage = GetCoverage(LinkedList[pointer].TangentAndCoverage);
			kBuffer[i].shadowAmmount = LinkedList[pointer].shadowAmmount;
			kBuffer[i].worldPos = LinkedList[pointer].worldPos;
			
			pointer = LinkedList[pointer].uNext;
			kBufferFragments++;
		}
		else
		{
			break;
		}
	}
	
	// Get the rest of the fragments on this pixel
	for (i = 0; i < MAX_FRAGMENTS; i++)
	{
		if (pointer == NULLPOINTER)
		{
			break;
		}
		
		maxDepth = 0;
		maxDepthIndex = 0;
		
		// Find the furthest kbuffer fragment
		for (j = 0; j < KBUFFER_SIZE; j++)
		{
			if (maxDepth < kBuffer[j].depth)
			{
				maxDepth = kBuffer[j].depth;
				maxDepthIndex = j;
			}
		}
		
		depth = LinkedList[pointer].depth;
		tangent = GetTangent(LinkedList[pointer].TangentAndCoverage);
		coverage = GetCoverage(LinkedList[pointer].TangentAndCoverage);
		shadowAmmount = LinkedList[pointer].shadowAmmount;
		worldPos = LinkedList[pointer].worldPos;
		
		// Exchange
		if (maxDepth > LinkedList[pointer].depth)
		{
			// Backup current values before overwriting
			float kDepth = depth;
			float3 kTangent = tangent;
			float kCoverage = coverage;
			float kAmmountLight = shadowAmmount;
			float2 kWorldPos = worldPos;
			
			// Exchange kBuffer -> Current
			depth = kBuffer[maxDepthIndex].depth;
			tangent = kBuffer[maxDepthIndex].tangent;
			coverage = kBuffer[maxDepthIndex].coverage;
			shadowAmmount = kBuffer[maxDepthIndex].shadowAmmount;
			worldPos = kBuffer[maxDepthIndex].worldPos;
			
			// Exchange backup -> kBuffer
			kBuffer[maxDepthIndex].depth = kDepth;
			kBuffer[maxDepthIndex].tangent = kTangent;
			kBuffer[maxDepthIndex].coverage = kCoverage;
			kBuffer[maxDepthIndex].shadowAmmount = kAmmountLight;
			kBuffer[maxDepthIndex].worldPos = kWorldPos;
		}
		
		// Do out of order blending and simple shading for fragments which dont make it into the KBuffer
		float3 worldPosition = float3(worldPos.xy, depth);
		
		float4 fragmentColor = float4(SimpleHairShading(worldPosition.xyz, tangent, shadowAmmount), coverage);
        fcolor.xyz = mad(-fcolor.xyz, fragmentColor.w, fcolor.xyz) + fragmentColor.xyz * fragmentColor.w;
		fcolor.w = mad(-fcolor.w, fragmentColor.w, fcolor.w);
		
		#ifdef COLORDEBUG
			nNumFragments++;
		#endif
		
		pointer = LinkedList[pointer].uNext;
	}
	
	
	#ifdef COLORDEBUG
    float3 debugColor = float3(0,1,0);
    if (nNumFragments<8) debugColor.xyz = float3(1,1,1);
    if (nNumFragments>32) debugColor.xyz = float3(1,1,0);
    if (nNumFragments>64) debugColor.xyz = float3(1,0.5,0);
    if (nNumFragments>128) debugColor.xyz = float3(1,0,0);
    
	Result[id.xy] = float4(debugColor, 0);
	#else
	
	float4 fragmentColor = float4(0,0,0,1);
	
	// Go through kbuffer in back-to-front order
	for (i = 0; i < kBufferFragments; i++)
	{
		maxDepth = 0;
		maxDepthIndex = 0;
		
		// Find the furthest kbuffer fragment
		for (j = 0; j < kBufferFragments; j++)
		{
			if (maxDepth < kBuffer[j].depth)
			{
				maxDepth = kBuffer[j].depth;
				maxDepthIndex = j;
			}
		}
		
		// Build world position
		float3 worldPos = float3(kBuffer[maxDepthIndex].worldPos, kBuffer[maxDepthIndex].depth);
		
		// Compute hair shading for current fragment and set coverage as alpha
		fragmentColor.xyz = ComputeHairShading(worldPos.xyz, kBuffer[maxDepthIndex].tangent, kBuffer[maxDepthIndex].shadowAmmount);
		fragmentColor.w = kBuffer[maxDepthIndex].coverage;
		
		// Blend fragments together
		fcolor.xyz = mad(-fcolor.xyz, fragmentColor.w, fcolor.xyz) + fragmentColor.xyz * fragmentColor.w;
		fcolor.w = mad(-fcolor.w, fragmentColor.w, fcolor.w);
		
		// Take this fragment out of the search
		kBuffer[maxDepthIndex].depth = 0;
	}
	
	Result[id.xy] = fcolor;
	
	#endif
}
